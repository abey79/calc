pub mod error_message;

use crate::context::checked_ast::Type;
use crate::data::token::TokenKind;
use error_message::ErrorSpan;
use thiserror::Error;

pub use error_message::Spanned;

// =================================================================================================
// PROGRAMMING ERROR

/// Errors generated by the tokenizer
#[derive(Error, Debug, PartialEq)]
pub enum SyntaxError {
    #[error("unexpected end of file")]
    UnexpectedEndOfFile,

    #[error("unexpected character '{0}'")]
    UnexpectedCharacter(char),

    #[error("unexpected token: {0}")]
    UnexpectedToken(TokenKind),

    #[error("unknown variable {0}")]
    UnknownVariable(String),

    #[error("empty tuple")]
    EmptyTuple,
}

/// Type errors
#[derive(Error, Debug, PartialEq)]
pub enum TypeError {
    #[error("invalid type {0} for unary operator")]
    InvalidTypeForUnaryOp(Type),

    #[error("mismatched types {0} and {1} for binary operator")]
    MismatchedTypesForBinaryOp(Type, Type),

    #[error("heterogeneous tuple")]
    HeterogeneousTuple,
}

// =================================================================================================
// PIPELINE ERRORS

/// Errors generated by the tokenizer
#[derive(Error, Debug, PartialEq)]
pub enum TokenizerError {
    #[error("{1}Syntax error: {0}")]
    SyntaxError(SyntaxError, ErrorSpan),
}

/// Errors generated by the parser
#[derive(Error, Debug, PartialEq)]
pub enum ParserError {
    #[error("{1}Syntax error: {0}")]
    SyntaxError(SyntaxError, ErrorSpan),

    #[error("Internal error")]
    InternalError,
}

/// Errors generated by the type checker
#[derive(Error, Debug, PartialEq)]
pub enum CheckerError {
    #[error("{1}Syntax error: {0}")]
    SyntaxError(SyntaxError, ErrorSpan),

    #[error("{1}Type error: {0}")]
    TypeError(TypeError, ErrorSpan),
}

/// Errors generated by the optimizer
#[derive(Error, Debug, PartialEq)]
pub enum OptimizerError {
    #[error("{1}Syntax error: {0}")]
    SyntaxError(SyntaxError, ErrorSpan),
}

/// Errors generated by the interpreter
#[allow(clippy::enum_variant_names)]
#[derive(Error, Debug, PartialEq)]
pub enum InterpreterError {
    #[error("{1}Syntax error: {0}")]
    SyntaxError(SyntaxError, ErrorSpan),

    #[error("{1}Type error: {0}")]
    TypeError(TypeError, ErrorSpan),

    #[error("I/O error")]
    IOError(#[from] std::fmt::Error),
}
