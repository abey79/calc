pub mod error_message;

use crate::context::checked_ast::Type;
use crate::data::token::TokenKind;
use error_message::ErrorMessage;
use thiserror::Error;

// =================================================================================================
// PROGRAMMING ERROR

/// Errors generated by the tokenizer
#[derive(Error, Debug, PartialEq)]
pub enum SyntaxError {
    #[error("unexpected end of file")]
    UnexpectedEndOfFile,

    #[error("unexpected character '{0}'")]
    UnexpectedCharacter(char),

    #[error("unexpected token: {0}")]
    UnexpectedToken(TokenKind),

    #[error("unknown variable {0}")]
    UnknownVariable(String),
}

/// Type errors
#[derive(Error, Debug, PartialEq)]
pub enum TypeError {
    #[error("invalid type {0} for unary operator")]
    InvalidTypeForUnaryOp(Type),

    #[error("mismatched types {0} and {1} for binary operator")]
    MismatchedTypesForBinaryOp(Type, Type),
}

// =================================================================================================
// PIPELINE ERRORS

/// Errors generated by the tokenizer
#[derive(Error, Debug, PartialEq)]
pub enum TokenizerError {
    #[error("{1}Syntax error:{0}")]
    SyntaxError(SyntaxError, ErrorMessage),
}

/// Errors generated by the parser
#[derive(Error, Debug, PartialEq)]
pub enum ParserError {
    #[error("{1}Syntax error:{0}")]
    SyntaxError(SyntaxError, ErrorMessage),

    #[error("internal error")]
    InternalError,
}

/// Errors generated by the type checker
#[derive(Error, Debug, PartialEq)]
pub enum CheckerError {
    #[error("{1}Syntax error:{0}")]
    SyntaxError(SyntaxError, ErrorMessage),

    #[error("{1}Type error:{0}")]
    TypeError(TypeError, ErrorMessage),
}

/// Errors generated by the optimizer
#[derive(Error, Debug, PartialEq)]
pub enum OptimizerError {
    #[error("{1}Syntax error:{0}")]
    SyntaxError(SyntaxError, ErrorMessage),
}
